{
  "blackrock-tableau-dashboard": {
    "id": "blackrock-tableau-dashboard",
    "PageTitle": "BlackRock Tableau Dashboard",
    "CoverPic": "https://res.cloudinary.com/eestevez/image/upload/v1627777210/myWorkPage/cardPics/app/blackRock.png",
    "Background": "In the summer of 2020, I had the privilege of interning with BlackRock, Inc., the worldâ€™s largest asset manager. As an Application Engineering Intern in their Summer Analyst Program, I was assigned to the Aladdin Product Group, specifically the Multi-Asset Strategies team.",
    "WhatIDid": "Collaborating with two other interns, I was tasked with collecting data points from various models to monitor the daily changes and interactions among assets. My responsibilities included importing and scraping CSV files, meticulously cleaning the data to ensure accuracy for subsequent calculations. Leveraging Python alongside libraries such as NumPy and pandas, I developed scripts to compute metrics like means and averages across asset classes. These scripts ran daily through Jenkins, culminating in the generation of a comprehensive CSV file. I then utilized Tableau to craft an interactive dashboard, providing portfolio managers with a visual representation of key performance indicators and model anomalies.",
    "WhatILearned": "While embarking on this internship, I possessed a foundational understanding of finance. However, my tenure at BlackRock propelled me to delve deeper into their operations and comprehend the significance of the data I handled within the financial landscape.",
    "CarouselImages": []
  },
  "workout-application": {
    "id": "workout-application",
    "PageTitle": "Workout Application",
    "CoverPic": "https://res.cloudinary.com/eestevez/image/upload/v1715663897/caseStudies/b8tevntgycyxvbcn4hbq.jpg",
    "Background": "During the fall semester of my senior year (Fall 2020), I embarked on a transformative journey in CS 506: Software Engineering. This dynamic course delved into the art of efficient software engineering within collaborative teams, emphasizing essential practices like version control and meticulous documentation. Throughout the semester, I was part of a dynamic team of 5 fellow students, collectively tackling the challenge of crafting a workout tracker application.",
    "WhatIDid": "In this project, my role extended across various facets of development. Leveraging the power of Figma, I contributed to the visual design and user interface of our application, ensuring an intuitive and visually appealing experience. Additionally, I played a pivotal role in integrating our front end with the backend API, seamlessly connecting to past workouts stored in MongoDB and hosted on Heroku. To maintain the quality of our application, I spearheaded efforts to implement automated UI testing using Android Studio and Espresso.",
    "WhatILearned": "This project catalyzed my exploration of new technologies and methodologies, pushing me to quickly adapt and thrive in a dynamic development environment. Embracing a proactive learning approach, I actively sought clarification and expanded my understanding of the technologies at hand. Furthermore, the experience of working within structured 2-week sprints under the guidance of our scrum master honed my skills in task management and agile development practices, enriching my professional toolkit.",
    "CarouselImages": [
      {
          "src": "https://res.cloudinary.com/eestevez/image/upload/v1627777204/myWorkPage/app/workout1.png",
          "label": "Figma Design for the Workout App",
          "desc": "Our team opted to utilize Figma for designing the app, facilitating seamless collaboration and iteration."
      },
      {
          "src": "https://res.cloudinary.com/eestevez/image/upload/v1627777204/myWorkPage/app/workout2.png",
          "label": "Prototype Design",
          "desc": "Prior to Figma, we employed Google Slides to outline the basic structure of our app, laying the foundation for further development."
      },
      {
          "src": "https://res.cloudinary.com/eestevez/image/upload/v1627777204/myWorkPage/app/workout3.png",
          "label": "Front End Testing",
          "desc": "We conducted comprehensive front-end tests using Jest to ensure the functionality and reliability of our app's user interface."
      },
      {
          "src": "https://res.cloudinary.com/eestevez/image/upload/v1627777204/myWorkPage/app/workout4.png",
          "label": "Back End Testing",
          "desc": "Similarly, we rigorously tested the back end of our app, including helper functions and endpoints, to validate its functionality and performance."
      },
      {
          "src": "https://res.cloudinary.com/eestevez/image/upload/v1715663889/caseStudies/xzcdhcdaaejj5woo4cnk.png",
          "label": "Design Persona",
          "desc": "Meet Bob Clarkson! This persona represents the average young male adult in Madison, WI. Crafting personas like Bob helped us better understand and tailor our app to our target users."
      }
  ]
  },
  "ti-tiva-launchpad-games": {
    "id": "ti-tiva-launchpad-games",
    "PageTitle": "TI Tiva Launchpad Games",
    "CoverPic": "https://res.cloudinary.com/eestevez/image/upload/v1627777210/myWorkPage/cardPics/app/tiva.png",
    "Background": "In both ECE 210: Intro to Electrical Engineering and ECE 353: Intro to Microprocessor Systems, I had hands-on experience with a TI Tiva Launchpad on a custom development board. Throughout these courses, I engaged with various peripherals including a touch screen, gyroscope, buttons, joystick, and LEDs. The culmination of each course involved developing a game using the skills acquired throughout the semester.",
    "WhatIDid": "Utilizing Keil uVision, I programmed the games in C language. This involved familiarizing myself with diverse packages and resolving compatibility issues with drivers to ensure seamless interaction between the games and hardware components. Additionally, I employed image compression tools to optimize image resolution for memory and screen constraints.",
    "WhatILearned": "These projects deepened my understanding of the intricate relationship between hardware and software. I gained insights into overcoming hardware limitations to enhance user experience, fostering a holistic perspective on system design and optimization.",
    "CarouselImages": []
  },
  "mips-16-bit-5-stage-pipelined-microprocessor": {
    "id": "mips-16-bit-5-stage-pipelined-microprocessor",
    "PageTitle": "MIPS 16-bit 5-stage Pipelined Microprocessor",
    "CoverPic": "https://res.cloudinary.com/eestevez/image/upload/v1627777210/myWorkPage/cardPics/app/552.png",
      "Background": "For the semester project of ECE 552: Intro to Computer Architecture, my partner and I undertook the task of designing and testing our own MIPS 16-bit 5-stage pipelined microprocessor, named the WISC-SP20, featuring data forwarding and cache.",
      "Background2": "The 5 stages of the processor were: 1st, the Instruction Fetch stage where the code instruction was loaded from memory. 2nd, the Decode stage where the 16-bit instruction was parsed. 3rd, the Execute stage where computation occurred, involving the Arithmetic Logic Unit (ALU) for an Add instruction. 4th, the Memory Access stage for accessing or writing data. 5th and last stage, the Writeback stage, storing the result in a working register.",
      "WhatIDid": "My partner and I first designed the non-pipelined single-cycle microprocessor. We sketched out the modules that would become the processor, clearly labeling them and describing the data paths for the required instruction set. When it came to writing Verilog code, we built the processor in multiple stages.",
      "WhatIDid_moreParagraphs": [
        "Within the first stage, we created the 5-stage single-cycle non-pipelined processor. We were provided perfect memory modules, eliminating concerns about stalling for multi-cycle memory fetching.",
        "The second phase implemented buffers between each stage to pipeline the processor, allowing multiple instructions to execute concurrently for improved CPI efficiency. We replaced perfect memory modules with stalling-aligned memory, accommodating slower memory access.",
        "The second to last phase included implementing a 2-way set-associative cache to enhance processor performance with realistic memory. The last phase introduced optimizations such as register file bypassing and memory forwarding, along with a branch prediction policy to handle branch outcomes efficiently."
      ],
      "WhatILearned": "This project provided a deep understanding of microprocessor architecture by constructing one from scratch and integrating realistic modules such as stalling-aligned memory and a 2-way set-associative cache. Building and running assembly programs on our custom microprocessor was a gratifying experience, solidifying my comprehension of instruction set architectures and computer organization.",
    "CarouselImages": [
      {
        "src": "https://res.cloudinary.com/eestevez/image/upload/v1627777204/myWorkPage/app/552_1.png",
        "label": "2-Way Set Associative Cache Schematic",
        "desc": "This image provides a comprehensive overview of the cache module utilized during the final phase of the project."
      },
      {
        "src": "https://res.cloudinary.com/eestevez/image/upload/v1627777210/myWorkPage/cardPics/app/552.png",
        "label": "Microprocessor Schematic",
        "desc": "An overview of the microprocessor in its non-pipelined state."
      },
      {
        "src": "https://res.cloudinary.com/eestevez/image/upload/v1627777204/myWorkPage/app/552_2.png",
        "label": "Assembly program written for the microprocessor by me",
        "desc": "This assembly program served as a test and demonstration of how the branch predictor consolidated its prediction within the decode stage of the processor."
      },
      {
        "src": "https://res.cloudinary.com/eestevez/image/upload/v1627777204/myWorkPage/app/552_3.png",
        "label": "Advanced Programs being run on the microprocessor",
        "desc": "For final testing, well-known algorithms such as bubble sort were executed on our microprocessor. The image showcases cycles, instruction memory fetches, and cache hit rate per program."
      }
    ]
    
  }
}
